\FOIL{Computing terminal SCCs using transitive closure}
\vfill
$\vj$ belongs to a terminal SCC iff 
$$\forall \vi, \vj \goesto{+} \vi \Longrightarrow \vi \goesto{+} \vj$$
\vspace{-3ex}

Given states $\vi,\vj$, let $\vj \to \vi$ denote
that $\vj \goesto{+} \vi~and~\lnot(\vi \goesto{+} \vj)$. 
$\vj$ is in a non-terminal SCC iff $\exists \vi. \vj \to \vi$.

Encode this relation with a $2L$-level MDD, which can be obtained as $TC^{-1}
\setminus TC$.

\begin{figure}
\ALGORITHM{$mdd ~~ \id{TSCC\_TC}(\nset^{-1})$} {
\LISTING{0}{
%\LL $mdd~N \!\ASSIGN\!   \id{QQencode}(\nset)$;
\LL $mdd~TC^{-1}  \!\ASSIGN\!  \id{TransClosureSat}(\nset^{-1})$; ~~~~ $mdd~TC \!\ASSIGN\!  \id{Inverse}(TC^{-1})$;
\LL $mdd~SCC \!\ASSIGN\! \id{TCtoSCC}(TC^{-1})$;
\LL $mdd~L \!\ASSIGN\! TC^{-1} \setminus TC$;
\LL $mdd~nontscc \!\ASSIGN\! \id{QuantifyUnprimed}(L)$;
\LL $mdd~recurrent \!\ASSIGN\! SCC \setminus nontscc$;
\LL return $recurrent$;
}}
\end{figure}

\LIST{
\BULL To the best of our knowledge, this is the first symbolic algorithm for terminal SCC computation using transitive closure.
\BULL This algorithm is more expensive in both runtime and memory than SCC computation because of the computation of the $\to$ relation.
\BULL With the help of $\id{TransClosureSat}$, this algorithm works for most of the models we study.
\\
It is the only known algorithm applicable to models with a huge number
of terminal SCCs.
}
